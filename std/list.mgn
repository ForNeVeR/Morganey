load functions
load logic
load math.arithmetic

nil := \a.b. b
isnil := \l.l (\h.t.d. (\a.b.b)) (\a.b.a)

/* Reverses the list `xs`
 */
reverse := \xs. Y (\reverseRec.xs.acc. (isnil xs) acc (reverseRec (tail xs) (cons (head xs) acc))) xs []

/* Range from `start` to `next`, with a step-size of `1`
 * example: range 1 5 = [1,2,3,4,5]
 * require: start <= end
 */
range := \start.end. rangeWithStep start 1 end

/* Range from `start` to `next`, with a step-size of `(next - start)`
 * example: rangeWithNext 1 3 10 = [1,3,5,7,9]
 * require: start <= end
 */
rangeWithNext := \start.next.end. rangeWithStep start (minus next start) end

/* Range from `start` to `next`
 * example: rangeWithStep 5 3 15 = [5,8,11,14]
 * require: start <= end
 */
rangeWithStep := Y (\rec.start.step.end. (le start end) (cons start (rec (plus start step) step end)) nil)

/* Maps function `f` over the elements of list `xs`
 */
map := \f.xs. Y (\mapRec.xs. (isnil xs) [] (cons (f (head xs)) (mapRec (tail xs)))) xs

/* Creates a list containing `n` times `x`
 */
replicate := \x.n. Y (\replicateRec.n.x.i. (lt i n) (cons x (replicateRec n x (succ i))) []) n x 0

foldl := \xs.zero.op. Y (\foldlRec.xs.acc.op. (isnil xs) acc (foldlRec (tail xs) (op acc (head xs)) op)) xs zero op

foldr := \xs.zero.op. foldl (reverse xs) zero (\a.b. op b a)

sum := \xs. foldl xs 0 plus

last := \xs. foldl xs [] (\a.b.b)

pair := \x.y.z. z x y
first := \n.n (\a.b.a)
second := \n.n (\a.b.b)

cons := pair
head := first
tail := second
